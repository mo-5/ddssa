import pandas as pd
import requests

from capstone_project.backend.parsing.package_ids import PackageIds


class VulnerabilityQuery:
    _instance = None
    _results = None
    _data = pd.DataFrame(index=["Name", "CVEs", "Mode"])
    _cves = set()
    _url = "https://services.nvd.nist.gov/rest/json/cpes/1.0/"

    def __init__(self):
        """Singletons in Python do not use __init__()"""
        raise RuntimeError("Use instance() instead.")

    @classmethod
    def instance(cls):
        """Singleton Pattern initialization"""
        if cls._instance is None:
            cls._instance = cls.__new__(cls)
        return cls._instance

    def query(self, df):
        """Queries the CPE API with each identified package
        included within the passed data frame."""
        for count, colData in df.iteritems():
            self._cves = set()
            # Determine the keyword for the query
            keyword = self._determine_keyword(colData.values)
            default_params = {
                "addOns": "cves",
                "keyword": keyword,
                "resultsPerPage": 2000,
                "startIndex": 0,
                "includeDeprecated": True,
            }
            # Remove any entries without CVEs listed
            self._prune_results(requests.get(self._url, params=default_params))
            # Keep only the results we wish to have based on the selected mode
            self._prune_by_mode(colData.values)
            self._data[str(count)] = [colData.values[0], self._cves, colData.values[2]]

        return self._data

    def _determine_keyword(self, col):
        """Determine the keyword to be used in the query."""
        pkg_name = col[0]
        ver_num = None

        if col[2] == PackageIds.SINGLE or col[2] == PackageIds.MAX:
            # Easy case, we can use the specific version identifier
            ver_num = col[1][0][1]

        return pkg_name if ver_num is None else f"{pkg_name} {ver_num}"

    def _prune_results(self, r):
        """Prune the query to only include entries that contain CVEs
        The returned data should already account for this, but this
        acts as a sanity check."""
        results = r.json()["result"]
        self._results = []
        for res in results["cpes"]:
            if "" != res["vulnerabilities"][0]:
                self._results.append(res)

    def _prune_by_mode(self, col):
        """Determine which results are relevant based on the mode
        and version information for the data."""
        if col[2] == PackageIds.SINGLE or col[2] == PackageIds.NO_VER:
            # Easiest case, just take all CVEs returned.
            for entry in self._results:
                self._add_to_set(entry["vulnerabilities"])
        elif col[2] == PackageIds.MAX:
            # For MAX, equal to or greater than the version provided.
            for entry in self._results:
                if col[1][0][0] == ">=":
                    if entry["cpe23Uri"].split(":")[5] >= col[1][0][1]:
                        self._add_to_set(entry["vulnerabilities"])
                else:
                    if entry["cpe23Uri"].split(":")[5] > col[1][0][1]:
                        self._add_to_set(entry["vulnerabilities"])
        elif col[2] == PackageIds.RANGE:
            # For RANGE, find start and go from those entries to end
            for entry in self._results:
                if col[1][0][0] == ">=" and col[1][1][0] == "<=":
                    if col[1][0][1] <= entry["cpe23Uri"].split(":")[5] <= col[1][1][1]:
                        self._add_to_set(entry["vulnerabilities"])
                elif col[1][0][0] == ">" and col[1][1][0] == "<=":
                    if col[1][0][1] < entry["cpe23Uri"].split(":")[5] <= col[1][1][1]:
                        self._add_to_set(entry["vulnerabilities"])
                elif col[1][0][0] == ">=" and col[1][1][0] == "<":
                    if col[1][0][1] <= entry["cpe23Uri"].split(":")[5] < col[1][1][1]:
                        self._add_to_set(entry["vulnerabilities"])
                else:
                    if col[1][0][1] < entry["cpe23Uri"].split(":")[5] < col[1][1][1]:
                        self._add_to_set(entry["vulnerabilities"])
        elif col[2] == PackageIds.EXCLUDE:
            # FOR EXCLUDE, find entries that match the version, drop those, operate the same as SINGLE afterwards.
            for entry in self._results:
                if entry["cpe23Uri"].split(":")[5] != col[1][0][1]:
                    self._add_to_set(entry["vulnerabilities"])

        # Sort the results by date.
        self._cves = sorted(self._cves)

    def _add_to_set(self, data):
        """Helper method to add data to a set."""
        for curr in data:
            self._cves.add(curr)


if __name__ == "__main__":
    vul = VulnerabilityQuery.instance()
    package_data = pd.DataFrame(index=["Name", "Version", "Range"])
    package_data["0"] = ["psutil", [("==", "1.5.1")], PackageIds.SINGLE]
    package_data["1"] = ["Django", [(">=", "1.5"), ("<", "1.6")], PackageIds.RANGE]
    package_data["2"] = ["numpy", [(">=", "1.5")], PackageIds.MAX]
    vul.query(package_data)
