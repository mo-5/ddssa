"""This module contains the Vulnerability Query class"""

from time import sleep

import numpy as np
import pandas as pd
import requests
from packaging import version

from pycvesearch import CVESearch
from requests import JSONDecodeError

from ddssa.backend.parsing.package_ids import PackageIds


class VulnerabilityQuery:
    """This class is used to query the backend CVE database"""

    _CPE_URI = "cpe23Uri"
    _VULNERABILITIES = "vulnerabilities"
    _DELIM = ":"
    _CVSS = "cvss"
    _instance = None
    _api_key = None
    _results = None
    _data = pd.DataFrame(
        index=[
            "Name",
            "Version",
            "CVEs",
            "Mode",
            "CVSS",
            "CVEName",
            "Summary",
            "Solution",
        ]
    )
    _cves = set()
    _scores = []
    _names = []
    _solutions = []
    _summaries = []
    _cvss = CVESearch("https://cve.circl.lu")
    _url = "https://services.nvd.nist.gov/rest/json/cpes/2.0/"

    def __init__(self, api_key=None):
        self._api_key = api_key

    def query(self, df):
        """Queries the CPE API with each identified package
        included within the passed data frame."""
        self._data = pd.DataFrame(
            index=[
                "Name",
                "Version",
                "CVEs",
                "Mode",
                "CVSS",
                "CVEName",
                "Summary",
                "Solution",
            ]
        )
        for i, col_data in df.iteritems():
            self._cves = set()
            self._scores = []
            self._names = []
            self._solutions = []
            self._summaries = []
            # Determine the keyword for the query
            keyword = self._determine_keyword(col_data.values)
            default_params = {
                "keywordSearch": keyword,
                "resultsPerPage": 20,
                "startIndex": 0,
            }

            # Add the API key if exists
            if self._api_key:
                default_params["apiKey"] = self._api_key

            # Execute the request, retrying if unsuccessful
            # TODO Change to exceptions and handle in UI, changed for now
            #      to make sure the demo goes without any issues.
            while True:
                response = requests.get(self._url, params=default_params)
                try:
                    if not response or "error" in response.json():
                        sleep(1)
                        continue
                except JSONDecodeError:
                    sleep(1)
                    continue
                break

            # Remove any entries without CVEs listed
            self._prune_results(response)
            # Keep only the results we wish to have based on the selected mode
            self._prune_by_mode(col_data.values)
            # Determine CVSS scores for any CVES
            self._add_cvss_score()
            # Sort by CVSS
            if len(self._scores) > 0:
                idx = np.argsort(self._scores)

                self._scores = np.array(self._scores)[idx][::-1]
                self._names = np.array(self._names)[idx][::-1]
                self._solutions = np.array(self._solutions)[idx][::-1]
                self._cves = np.array(self._cves)[idx][::-1]

            # Only add the entry if vulnerabilities were detected.
            if len(self._cves) > 0:
                self._data[str(i)] = [
                    col_data.values[0],
                    col_data.values[1],
                    self._cves,
                    col_data.values[2],
                    self._scores,
                    self._names,
                    self._summaries,
                    self._solutions,
                ]
        return self._data

    def _determine_keyword(self, col):
        """Determine the keyword to be used in the query."""
        pkg_name = col[0]
        ver_num = None

        if col[2] == PackageIds.SINGLE or col[2] == PackageIds.MAX:
            # Easy case, we can use the specific version identifier
            ver_num = col[1][0][1]

        return pkg_name if ver_num is None else f"{pkg_name} {ver_num}"

    def _prune_results(self, r):
        """Prune the query to only include entries that contain CVEs
        The returned data should already account for this, but this
        acts as a sanity check."""
        results = r.json()["result"]
        self._results = []
        for res in results["cpes"]:
            if "" != res[self._VULNERABILITIES][0]:
                self._results.append(res)

    def _prune_by_mode(self, col):
        """Determine which results are relevant based on the mode
        and version information for the data."""
        if col[2] == PackageIds.SINGLE or col[2] == PackageIds.NO_VER:
            # Easiest case, just take all CVEs returned.
            for entry in self._results:
                self._cves.update(entry[self._VULNERABILITIES])
        elif col[2] == PackageIds.MAX:
            # For MAX, equal to or greater than the version provided.
            for entry in self._results:
                if col[1][0][0] == ">=":
                    if version.parse(
                        entry[self._CPE_URI].split(self._DELIM)[5]
                    ) >= version.parse(col[1][0][1]):
                        self._cves.update(entry[self._VULNERABILITIES])
                else:
                    if version.parse(
                        entry[self._CPE_URI].split(self._DELIM)[5]
                    ) > version.parse(col[1][0][1]):
                        self._cves.update(entry[self._VULNERABILITIES])
        elif col[2] == PackageIds.RANGE:
            # For RANGE, find start and go from those entries to end
            for entry in self._results:
                if col[1][0][0] == ">=" and col[1][1][0] == "<=":
                    if (
                        version.parse(col[1][0][1])
                        <= version.parse(entry[self._CPE_URI].split(self._DELIM)[5])
                        <= version.parse(col[1][1][1])
                    ):
                        self._cves.update(entry[self._VULNERABILITIES])
                elif col[1][0][0] == ">" and col[1][1][0] == "<=":
                    if (
                        version.parse(col[1][0][1])
                        < version.parse(entry[self._CPE_URI].split(self._DELIM)[5])
                        <= version.parse(col[1][1][1])
                    ):
                        self._cves.update(entry[self._VULNERABILITIES])
                elif col[1][0][0] == ">=" and col[1][1][0] == "<":
                    if (
                        version.parse(col[1][0][1])
                        <= version.parse(entry[self._CPE_URI].split(self._DELIM)[5])
                        < version.parse(col[1][1][1])
                    ):
                        self._cves.update(entry[self._VULNERABILITIES])
                else:
                    if (
                        version.parse(col[1][0][1])
                        < version.parse(entry[self._CPE_URI].split(self._DELIM)[5])
                        < version.parse(col[1][1][1])
                    ):
                        self._cves.update(entry[self._VULNERABILITIES])
        elif col[2] == PackageIds.EXCLUDE:
            # FOR EXCLUDE, find entries that match the version, drop those, operate
            # the same as SINGLE afterwards.
            for entry in self._results:
                if version.parse(
                    entry[self._CPE_URI].split(self._DELIM)[5]
                ) != version.parse(col[1][0][1]):
                    self._cves.update(entry[self._VULNERABILITIES])

        # Sort the results by date.
        self._cves = sorted(self._cves)

    def _add_cvss_score(self):
        """Determine CVSS 2.0 scores for a given CVE, without querying
        the NIST CVE database directly. Also adds the CVE name, summary,
        and possible solutions if available."""
        for cve in self._cves:
            try:
                info = self._cvss.id(cve)
                if len(info["capec"]) != 0:
                    try:
                        name = info["capec"][0]["name"]
                        solution = info["capec"][0]["solutions"]
                        summary = info["capec"][0]["summary"]
                    except KeyError:
                        self._names.append("Unavailable")
                        self._solutions.append(
                            "<u>If possible, upgrade to the latest package release.</u>"
                        )
                        self._summaries.append("Unavailable")
                        return
                    if name is not None:
                        self._names.append(name)
                    else:
                        self._names.append("Unavailable")
                    if solution is not None:
                        self._solutions.append(
                            f"<u>If possible, upgrade to the latest package release.</u><br/>{solution}"
                        )
                    else:
                        self._solutions.append(
                            "<u>If possible, upgrade to the latest package release.</u>"
                        )
                    if summary is not None:
                        self._summaries.append(summary)
                    else:
                        self._summaries.append("Unavailable")
                else:
                    self._names.append("Unavailable")
                    self._solutions.append(
                        "<u>If possible, upgrade to the latest package release.</u>"
                    )
                    self._summaries.append("Unavailable")
                score = info["cvss"]
                if score is not None:
                    self._scores.append(score)
                else:
                    self._scores.append("Unknown")
            except ConnectionError:
                self._scores.append("Unknown")
                self._names.append("Unavailable")
                self._solutions.append(
                    "<u>If possible, upgrade to the latest package release.</u>"
                )
                self._summaries.append("Unavailable")
            except KeyError:
                self._scores.append("Unknown")
                self._names.append("Unavailable")
                self._solutions.append(
                    "<u>If possible, upgrade to the latest package release.</u>"
                )
                self._summaries.append("Unavailable")
